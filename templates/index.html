<!-- templates/index.html -->
<!DOCTYPE html>
<html>
  <head>
    <title>Powerful Owl Finder</title>
  </head>
  <body style="padding-left: 20px; padding-right: 20px;">
    <h1>Listening for Powerful Owls? ðŸ¦‰</h1>
    <form id="owlsForm" action="/stream_predict" method="post" enctype="multipart/form-data">
        <label for="file">Choose an audio file:</label>

        <input type="file" id="file" name="file" accept="/">
        <input type="submit" value="Upload and look for owls">
    </form>
    <hr>
    <div id="results"></div>
  <script>
    // Intercept form submission and render the server-sent events
    document.getElementById('owlsForm').addEventListener('submit', function(e) {
        e.preventDefault(); // Prevents default form submission
        var formData = new FormData(this);
        submitForm(formData);
    });

    let detections = [];
    let raw_chunks = [];
    let chunk_count = 0;

    async function submitForm(formData) {
        detections = [];
        raw_chunks = []
        chunk_count = 0;
        
        const fileInput = document.getElementById('file');
        const file = fileInput.files[0];
        
        if (file.type == "audio/wav") {
            document.getElementById('results').innerHTML = 'Chunking WAV audio file...';
            // we can chunk locally
            const chunkSize = 2 * 1024 * 1024; // 2MB per chunk
            let offset = 0
            while (offset < file.size) {
                const chunk = file.slice(offset, offset + chunkSize);
                const formData = new FormData();
                formData.append('file', chunk);
                await streamPredictions(formData);
                offset += chunkSize;
            }
        } else {
            document.getElementById('results').innerHTML = 'Uploading audio file...';
            streamPredictions(formData);
        }
    }

    function streamPredictions(formData) {
        fetch('/stream_predict', {
            method: 'POST',
            body: formData,
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            // document.getElementById('results').innerHTML = '';
            return response.body;
        })
        .then(stream => {
            // Handle the stream
            const reader = stream.getReader();
            readStream(reader);
        })
        .catch(error => {
            console.error('Error:', error);
        });
    }

    function renderDetections() {
        console.log(detections, raw_chunks, chunk_count);

        html = ""

        // Print summary
        html = '<p>';
        raw_chunks.forEach(chunk => {
            if (chunk.detected) {
                html += "ðŸŸ©"
            } else {
                html += "â¬œ"
            }
        });

        for (let i = 0; i < (chunk_count - raw_chunks.length); i++) {
            html += "â¬›"
        }
        html += "</p>";

        detections.forEach(detection => {
            if (detection.detected) {
                html += "<p style='color: green'>Owls detected at " + detection.start_time + " to " + detection.end_time + " seconds</p>"
            } else {
                html += "<p>No owls detected at " + detection.start_time + " to " + detection.end_time + " seconds</p>"
            }
        });
        document.getElementById('results').innerHTML = html;
    }

    function readStream(reader) {
        reader.read().then(({ done, value }) => {
            if (done) {
                console.log('Stream complete');
                document.getElementById('results').innerHTML += "<p>Done processing!</p>";
                return;
            }
            // Process the chunk (value)
            const decoder = new TextDecoder();
            const raw_text = decoder.decode(value);

            const predictions = raw_text.split("\n\n");

            predictions.forEach((text) => {
                try {
                    const jsonObj = JSON.parse(text);
                    detections.push(jsonObj);
                    raw_chunks.push(jsonObj);
                    chunk_count = jsonObj.chunk_count;
                } catch (e) {
                    console.error("Error parsing JSON:", e, text);
                }
            })


            detections = mergeEvents(detections);
            renderDetections(detections)

            console.log(raw_text);
            // Read the next chunk
            readStream(reader);
        });
    }

    function mergeEvents(events) {
        let mergedEvents = [];
        let currentEvent = null;

        events.forEach(event => {
            // Check if we have a current event to possibly merge with
            if (currentEvent) {
                // Check if the current event can be merged with this one
                if (currentEvent.detected === event.detected && currentEvent.end_time === event.start_time) {
                    // Merge this event by extending the end_time of the current event
                    currentEvent.end_time = event.end_time;
                } else {
                    // The current event cannot be merged; add it to the mergedEvents and start a new current event
                    mergedEvents.push(currentEvent);
                    currentEvent = event;
                }
            } else {
                // This is the first event or after a non-mergeable event
                currentEvent = event;
            }
        });

        // Don't forget to add the last event if it exists
        if (currentEvent) {
            mergedEvents.push(currentEvent);
        }

        return mergedEvents;
    }

  </script>
  </body>
</html>