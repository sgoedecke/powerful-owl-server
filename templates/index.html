<!-- templates/index.html -->
<!DOCTYPE html>
<html>
  <head>
    <title>Powerful Owl Finder</title>
  </head>
  <body style="padding-left: 20px; padding-right: 20px;">
    <h1>Listening for Powerful Owls? ðŸ¦‰</h1>
    <form id="owlsForm" action="/stream_predict" method="post" enctype="multipart/form-data">
        <label for="file">Choose an audio file:</label>

        <input type="file" id="file" name="file" accept="/">
        <input type="submit" value="Upload and look for owls">
    </form>
    <hr>
    <div id="results"></div>
  <script>
    // Intercept form submission and render the server-sent events
    document.getElementById('owlsForm').addEventListener('submit', function(e) {
        e.preventDefault(); // Prevents default form submission
        var formData = new FormData(this);
        submitForm(formData);
    });

    let detections = [];
    let raw_chunks = [];
    let chunk_count = 0;

    async function submitForm(formData) {
        detections = [];
        raw_chunks = []
        chunk_count = 0;
        
        const fileInput = document.getElementById('file');
        const file = fileInput.files[0];
        
        if (file.type == "audio/wav") {
            document.getElementById('results').innerHTML = 'Chunking WAV audio file...';
            header = await readWavHeader(file);
            // channels: channels,
            // sampleRate: sampleRate,
            // bitDepth: bitDepth
            console.log("Header:", header)
            const bytesPerSample = header.bitDepth / 8;
            const frameSize = header.channels * bytesPerSample; // Size of each frame in bytes
            const chunkDurationMs = 20 * 1000; // Duration of each chunk in milliseconds
            const chunkSizeInBytes = header.sampleRate * chunkDurationMs / 1000 * frameSize; // Size of each chunk in bytes

            for (let start = 44; start < file.size; start += chunkSizeInBytes) { // start at 44 to offset the header
                let chunk = file.slice(start, Math.min(file.size, start + chunkSizeInBytes));
                chunk = createWavChunk(header.buffer, chunk);
                const formData = new FormData();
                formData.append('file', chunk);
                await streamPredictions(formData);
            }
        } else {
            document.getElementById('results').innerHTML = 'Uploading audio file...';
            streamPredictions(formData);
        }
    }

    function streamPredictions(formData) {
        fetch('/stream_predict', {
            method: 'POST',
            body: formData,
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            // document.getElementById('results').innerHTML = '';
            return response.body;
        })
        .then(stream => {
            // Handle the stream
            const reader = stream.getReader();
            readStream(reader);
        })
        .catch(error => {
            console.error('Error:', error);
        });
    }

    function renderDetections() {
        console.log(detections, raw_chunks, chunk_count);

        html = ""

        // Print summary
        html = '<p>';
        raw_chunks.forEach(chunk => {
            if (chunk.detected) {
                html += "ðŸŸ©"
            } else {
                html += "â¬œ"
            }
        });

        for (let i = 0; i < (chunk_count - raw_chunks.length); i++) {
            html += "â¬›"
        }
        html += "</p>";

        detections.forEach(detection => {
            if (detection.detected) {
                html += "<p style='color: green'>Owls detected at " + detection.start_time + " to " + detection.end_time + " seconds</p>"
            } else {
                html += "<p>No owls detected at " + detection.start_time + " to " + detection.end_time + " seconds</p>"
            }
        });
        document.getElementById('results').innerHTML = html;
    }

    function readStream(reader) {
        reader.read().then(({ done, value }) => {
            if (done) {
                console.log('Stream complete');
                document.getElementById('results').innerHTML += "<p>Done processing!</p>";
                return;
            }
            // Process the chunk (value)
            const decoder = new TextDecoder();
            const raw_text = decoder.decode(value);

            const predictions = raw_text.split("\n\n");

            predictions.forEach((text) => {
                try {
                    const jsonObj = JSON.parse(text);
                    detections.push(jsonObj);
                    raw_chunks.push(jsonObj);
                    chunk_count = jsonObj.chunk_count;
                } catch (e) {
                    console.error("Error parsing JSON:", e, text);
                }
            })


            detections = mergeEvents(detections);
            renderDetections(detections)

            console.log(raw_text);
            // Read the next chunk
            readStream(reader);
        });
    }

    function mergeEvents(events) {
        let mergedEvents = [];
        let currentEvent = null;

        events.forEach(event => {
            // Check if we have a current event to possibly merge with
            if (currentEvent) {
                // Check if the current event can be merged with this one
                if (currentEvent.detected === event.detected && currentEvent.end_time === event.start_time) {
                    // Merge this event by extending the end_time of the current event
                    currentEvent.end_time = event.end_time;
                } else {
                    // The current event cannot be merged; add it to the mergedEvents and start a new current event
                    mergedEvents.push(currentEvent);
                    currentEvent = event;
                }
            } else {
                // This is the first event or after a non-mergeable event
                currentEvent = event;
            }
        });

        // Don't forget to add the last event if it exists
        if (currentEvent) {
            mergedEvents.push(currentEvent);
        }

        return mergedEvents;
    }

    function readWavHeader(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            
            // Only read the first 44 bytes (WAV header length)
            const blob = file.slice(0, 44);
            reader.readAsArrayBuffer(blob);
            
            reader.onload = function(e) {
                const buffer = e.target.result;
                const view = new DataView(buffer);
                
                // Ensure this is a RIFF file and it's a WAVE audio file
                if (readString(view, 0, 4) !== 'RIFF' || readString(view, 8, 4) !== 'WAVE') {
                    reject(new Error('Not a valid WAV file'));
                    return;
                }
                
                const channels = view.getUint16(22, true);
                const sampleRate = view.getUint32(24, true);
                const bitDepth = view.getUint16(34, true);
                
                resolve({
                    channels: channels,
                    sampleRate: sampleRate,
                    bitDepth: bitDepth,
                    buffer: buffer
                });
            };
            
            reader.onerror = function(err) {
                reject(err);
            };
        });
    }

    // Helper function to read strings from a DataView
    function readString(view, start, length) {
        let result = '';
        for (let i = start; i < start + length; i++) {
            result += String.fromCharCode(view.getUint8(i));
        }
        return result;
    }

    function createWavChunk(originalHeader, audioDataChunk) {
        // Assuming originalHeader is the ArrayBuffer of the original 44-byte WAV header
        // Convert originalHeader ArrayBuffer to DataView for easier manipulation
        let headerView = new DataView(originalHeader.slice(0));

        // Calculate new sizes
        let fileSize = audioDataChunk.size + 36; // Overall file size minus 8 bytes of RIFF header
        let dataChunkSize = audioDataChunk.size; // Size of the actual audio data

        // Set fileSize in the RIFF chunk header, offset 4 bytes, 4 bytes long
        headerView.setUint32(4, fileSize, true);

        // Set dataChunkSize in the data subchunk, offset 40 bytes, 4 bytes long
        headerView.setUint32(40, dataChunkSize, true);

        // Combine the modified header with the audio data chunk into a new Blob
        let combinedChunk = new Blob([headerView, audioDataChunk], {type: 'audio/wav'});

        return combinedChunk;
    }


  </script>
  </body>
</html>